#*****************  ENCODING ********************#
   transitions       | separator|
1011110101111011        00
1010101011              00
101101011011            00
101110110111101         00
11010111011101          00
110110111110111101      00
1110101110101           00
1110110111101101        00
111101111011110111101   00
1111010101111011        00


#*****************  TM STRUCT ********************#
#*******# data
struct {
    state   actual; //(Qa)
    char*   tape;   //[.....]
    int     head;   // <> (idx on tape)
}
schema:
    Qa
    [........<.>.....]


Q = {Q1, .., Qn}


#*****************  PARSING ENCODED ********************#
#*******# variable
nΣ = 0                      // number of letter (alphabet size)
nQ = 0                      // number of states
A = {1, 11}
  = {LEFT, RIGHT}           // ACTIONS
Fq = []                     // Function State (transition function) list (empty at start)


// parsing first transition (up until '00' separator)
#*******#   t1 (transition1)
1011110101111011        00

// human readable view
Qa  read    Qs  write  A
1   1111    1   1111   11
1   l4      1   l4     2

We find 1 state (q1) and 4 letter (l4) ->
    nQ = 1
    nΣ = 4

We found q1t1 but Fq is empty so we need to create Fq1 (Fq.at(1) doesnt exist)
    Fq1 = []
    Fq1_1(4, (1,4,2))
    Fq1.append(Q1t1)
    Fq.append(Fq1)


[...]

Raw Fq = [
    [   // Fq1
        (4, 1, 4, 2),
        (1, 1, 1, 2),
        (2, 1, 2, 2),
        (3, 2, 4, 1)
    ],
    [   //Fq2
        (1, 3, 3, 1),
        (2, 5, 4, 1)
    ],
    [   //Fq3
        (1, 3, 1, 1),
        (2, 4, 2, 1)
    ],
    [   //Fq4
        (4, 4, 4, 1),
        (1, 1, 4, 2)
    ],
]

Ordered Raw Fq = [
    [   // Fq1
        (1, 1, 1, 2),
        (2, 1, 2, 2),
        (3, 2, 4, 1),
        (4, 1, 4, 2)
    ],
    [   //Fq2
        (1, 3, 3, 1),
        (2, 5, 4, 1)
    ],
    [   //Fq3
        (1, 3, 1, 1),
        (2, 4, 2, 1)
    ],
    [   //Fq4
        (1, 1, 4, 2),
        (0, 0, 0, 0),
        (0, 0, 0, 0),
        (4, 4, 4, 1)
    ],
]


Final Tr = [
    [   // TrQ1
        (1, 1, 2),
        (1, 2, 2),
        (2, 4, 1),
        (1, 4, 2)
    ],
    [   // TrQ2
        (3, 3, 1),
        (5, 4, 1)
    ],
    [   // TrQ3
        (3, 1, 1),
        (4, 2, 1)
    ],
    [   // TrQ4
        (1, 4, 2),
        (-1, 0, 0),
        (-1, 0, 0),
        (4, 4, 1)
    ],
]



#*******#  pseudo code algo


increaseTape tape dir default
    | dir == 1 = default:tape
    | dir == 2 = tape:default


moveHead tape action
    | action == 1 = head - 1
    | action == 2 = head + 1

main =
    tape = [input]
    head = 0
    Qa = 0
    algo tape head Qa Tr Σ


algo tape head Qa Tr Σ blank =

    QaTr = Tr !! Qa                                 // get transition list for state Qa
    readValue = tape !! head                        // read value at index 'head' on tape
    rValueIdx =  elemIndex readValue Σ              // 'encode' value to numerical represnetaion (get index in alphabet)
    (write, Qs, action) = QaTr  !! rValueIdx        // get transition to apply (write, state, action)

    //FIXME: handle head < 0
    tape = writeTape tape write head Σ blank        // write to tape
    // FIXME: increase tape
    head = moveHead head action                     // move head to LEFT/RIGHT

    if Qs < lenght(Tr)                              // if Qs has transition, continue
    then algo tape head Qs Tr Σ blank               // Qs has no transition -> final state
    else "END"


algo tape head Qa Tr Σ blank
    | Qa >= lenght(Tr) = "END"
    | otherwise =
            QaTr = Tr !! Qa
            readValue = tape !! head
            rValueIdx =  elemIndex readValue Σ
            (write, Qs, action) = QaTr  !! rValueIdx
            tape = writeTape tape write head Σ blank
            head = moveHead head action
            algo tape head Qs Tr Σ blank
